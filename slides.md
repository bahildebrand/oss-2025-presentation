## Efficient On-Device Core Dump Processing for IoT: A Rusty Implementation

---

<!-- .slide: data-auto-animate -->

## What's In a Coredump?

--

<!-- .slide: data-auto-animate -->

```bash [1| 3-9]
readelf -l core.elf

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  NOTE           0x0000000000000a50 0x0000000000000000 0x0000000000000000
                 0x0000000000002234 0x0000000000000000         0x4
  LOAD           0x0000000000002c88 0x00006119ededc000 0x0000000000000000
                 0x00000000000003d4 0x00000000000003d4         0x8
                 ...
```

---

## Where Is It Coming From?

--

```bash [2]
cat /proc/sys/kernel/core_pattern
|/usr/sbin/memfault-core-handler -c /etc/memfaultd.conf %P %I %s
```

---

## What is a Coredump?

* **Definition:** A snapshot of a crashing process's memory, formatted as an ELF file.
* **Triggers:** Generated by specific signals (e.g., `SIGSEGV`, `SIGBUS`, `SIGABRT`).
  * Indicate serious bugs (e.g., invalid memory access, null pointer dereference).
* **Enabling Coredumps:**
  * Kernel configuration: `CONFIG_COREDUMP=y`, `CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y`.
  * `ulimit -c unlimited`: Sets maximum coredump size.
* **`core_pattern`:** Controls where and how coredumps are written.
  * Direct to file: `/tmp/core.%e.%p`
  * Pipe to program: `|/usr/sbin/memfault-core-handler ...`
    * Allows in-flight modification and access to `procfs`.

---

## ELF Core File Layout

* **ELF Header:** Outlines file layout, system architecture (e.g., 32-bit/64-bit, endianness).
  * `e_type` is `ET_CORE`.
  * `e_machine` indicates architecture (e.g., `EM_ARM`, `EM_AARCH64`).
* **Program Headers & Segments:** The "meat" of the coredump.
  * `PT_NOTE`: Contains metadata (e.g., process status, signal info).
    * Free-form; can add custom metadata.
  * `PT_LOAD`: Represents segments of memory loaded into the process (stack, heap, etc.).
* **Memfault's Rev. 1 Approach:**
  * Stream `PT_LOAD` segments from `/proc/<pid>/mem` to reduce handler memory footprint.
  * Add custom `PT_NOTE` for device metadata.
  * Result: Largely standard coredump with added metadata.

---

## Shrinking the Core

* **Goal:** Reduce coredump size while retaining critical debugging info.
* **Key Requirements for a "Slim" Coredump:**
  1. Limit each stack to the top N bytes.
  2. Remove heap allocations.
  3. Capture essential metadata for debuggers.
* **Tradeoffs:**
  * No heap-allocated values on stack or in heap.
  * Limited stack depth, but usually only top frames are of interest.

---

## Finding Stacks and Debug Info

* **Finding Stacks:**
  * Use `NT_PRSTATUS` note to get `pr_reg` (General Purpose Registers).
  * Extract `PC` for each thread.
  * Iterate `/proc/<pid>/maps` to find memory regions for each PC.
  * Copy limited bytes from PC down to stack start.
* **`r_debug` - Debug Rendezvous Structure:**
  * Crucial for translating compile-time addresses to runtime addresses (ASLR).
  * `link_map`'s `l_addr` maps ELF addresses to runtime addresses.
  * Found via `DT_DEBUG` tag in `PT_DYNAMIC` program header.
* **Build IDs and Headers:**
  * For each mapped ELF file (main binary, dynamic libs):
    * ELF header
    * All program headers
    * Build ID note (`.note.gnu.build-id`)
  * Obtained by parsing `/proc/pid/maps` for executable files.

---

## Size Savings

* **Example Comparison:**
  * **Default Coredump:** ~2.6 MB
  * **Slim Coredump (with modifications):** ~75 KB
* **Result:** A **35x size reduction!**
* **Impact:**
  * Opens up possibility of storing multiple coredumps on constrained devices.
  * Predictable and smaller size.

---

## On-Device Unwinding - The Next Step

* **Motivation:**
  * Prevent sensitive PII from leaving the device.
  * Further reduce coredump size by *only* capturing PCs.
* **The Goal:** Strip away all captured memory, leaving only essential information for symbolication.
  * No risk of sensitive data leakage.
  * Massive size reduction.

---

## What Information Do We Need?

* **At a minimum:** `PC` (program counter) for each frame.
* **To be useful (symbolication):**
  * `PC` for each frame on every thread.
  * For main binary and all dynamic libs:
    * `PC` range
    * GNU build ID
    * Compile time and runtime offset (for ASLR).
    * Path
* **Output Structure (JSON example):**

  ```json
  {
    "symbols": [
      {
        "pc_range": { "start": "...", "end": "..." },
        "build_id": "...",
        "compiled_offset": "...",
        "runtime_offset": "...",
        "path": "..."
      }
    ],
    "threads": [
      {
        "pcs": [ "...", "..." ]
      }
    ]
  }
  ```

---

## GNU Unwind Info (`.eh_frame`)

* **Purpose:** Allows reconstruction of previous frame structure (register locations, local variables).
* **Key Sections:**
  * `.eh_frame`: Contains rules to rebuild frame info.
  * `.eh_frame_hdr`: Sibling section.
* **Core Concepts:**
  * **CFI (Common Frame Information):** Grouping of frame info.
  * **CIE (Common Information Entry):** Shared instructions for FDEs.
  * **FDE (Frame Description Entry):** Specific instructions to recreate a frame's structure.
    * Includes `PC` range.
  * **CFA (Canonical Frame Address):** Base address of the frame being reconstructed.
    * Example: `DW_CFA_def_cfa: r7 (rsp) ofs 8` means CFA = RSP + 8.
  * **Register Offsets:** `DW_CFA_offset: r16 (rip) at cfa-8` (RIP = CFA - 8).

---

## Tying It All Together

* **Inputs Collected:**
  * GP registers from `prstatus` note.
  * Binary/dynamic lib address range.
  * Runtime offset.
  * Binary path.
  * `.eh_frame`/`.eh_frame_hdr` sections from each binary.
  * Build ID from `.note.gnu.build-id`.
* **Steps for Symbolication (per PC in a thread):**
  1. Find associated symbols by checking `PC` range.
  2. Fetch symbol file (by build ID or path).
  3. Shift `PC` for ASLR: `address - runtime_offset + compiled_offset`.
  4. Run shifted address and symbol file through `addr2line`.

---

## Example Output & Result

* **Example On-Device Unwind Output (JSON):**

  ```json
  {
    "version": "1",
    "signal": "SIGSEGV",
    "cmdline": "memfaultctl\u0000trigger-coredump\u0000",
    "symbols": [ /* ... */ ],
    "threads": [
      {
        "active": true,
        "pcs": [
          "0x55ea82cff77c", /* ... */
        ]
      }
    ]
  }
  ```

* **Example Symbolication:**
  * PC: `0x55ea82cff77c`
  * ASLR Shift Calculation: `0x55ea82cff77c - 0x55ea82cc4000 + 0x1bd000 = 0x1f877c`
  * `addr2line -Cf -e /path/to/memfaultd 1f877c`
  * **Output:** `core::ptr::write /rustc/.../core/src/ptr/mod.rs:1377`
* **Outcome:** Fully symbolicated stacktrace, preserving privacy and with minimal size.

---

## Conclusion

* **Traditional coredumps:** Powerful but large and can leak sensitive data.
* **Shrinking the Core (Part 2):** Significantly reduced size by stripping heap and limiting stack depth.
  * ~35x size reduction.
* **On-Device Unwinding (Part 3):** The ultimate solution for privacy and size.
  * No memory sections leave the device.
  * Only program counters (PCs) and necessary metadata are collected.
  * Leverages `.eh_frame` and `addr2line` for local stack unwinding.

* **Result:** Efficient, privacy-preserving crash capture for embedded Linux IoT devices.

---

## Q&A

* **Thank you!**
* **Further Reading:**
  * [Linux Coredumps (Part 1) - Introduction](https://interrupt.memfault.com/blog/linux-coredumps-part-1)
  * [Linux Coredumps (Part 2) - Shrinking the Core](https://interrupt.memfault.com/blog/linux-coredumps-part-2)
  * [Linux Coredumps (Part 3) - On Device Unwinding](https://interrupt.memfault.com/blog/linux-coredumps-part-3)
* **Source Code:** [memfault/memfaultd](https://github.com/memfault/memfaultd/tree/main/memfaultd/src/cli/memfault_core_handler/stack_unwinder)
